<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Robo-Link: Cyber Circuit</title>
    <style>
        :root { --neon: #00f3ff; --danger: #ff0055; --bg: #050508; --tile-bg: #11111d; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; touch-action: none; }
        
        #hud { position: fixed; top: 20px; width: 100%; display: flex; justify-content: space-around; z-index: 100; pointer-events: none; }
        .stat { background: rgba(0,0,0,0.8); padding: 12px 25px; border: 1px solid var(--neon); border-radius: 8px; box-shadow: 0 0 15px var(--neon); color: var(--neon); font-size: 16px; font-weight: bold; }

        #grid-container { position: relative; padding: 20px; background: #0c0c14; border: 3px solid #1a1a2e; border-radius: 20px; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        #grid { display: grid; grid-template-columns: repeat(4, 75px); grid-template-rows: repeat(4, 75px); gap: 8px; }

        .indicator { position: absolute; font-size: 12px; font-weight: bold; text-transform: uppercase; }
        .source-tag { top: -20px; left: 20px; color: var(--neon); animation: pulse 1.5s infinite; }
        .core-tag { bottom: -20px; right: 20px; color: var(--danger); }

        .tile { width: 75px; height: 75px; background: var(--tile-bg); border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid #222; }
        .tile svg { width: 80%; height: 80%; stroke: #333; stroke-width: 12; fill: none; transition: 0.4s; stroke-linecap: round; }
        
        .tile.active { background: rgba(0, 243, 255, 0.1); border-color: var(--neon); }
        .tile.active svg { stroke: var(--neon); filter: drop-shadow(0 0 5px var(--neon)); }

        @keyframes pulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.1); } }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; text-align: center; }
        button { padding: 18px 60px; font-size: 22px; background: var(--neon); border: none; color: black; font-weight: bold; border-radius: 8px; cursor: pointer; margin-top: 30px; box-shadow: 0 0 25px var(--neon); transition: 0.2s; }
        button:active { transform: scale(0.9); }
    </style>
</head>
<body>

<div id="hud">
    <div class="stat">‚ö° POWER: <span id="p-level">0</span>%</div>
    <div class="stat">üíé RC: <span id="rc">0</span></div>
</div>

<div id="grid-container">
    <div class="indicator source-tag">‚óè Input Signal</div>
    <div id="grid"></div>
    <div class="indicator core-tag">Output Target ‚óè</div>
</div>

<div id="start-screen" class="overlay">
    <h1 style="color: var(--neon); font-size: 45px; margin:0; letter-spacing: 5px;">ROBO-LINK</h1>
    <p style="opacity: 0.8; margin-top: 10px;">REPAIR THE CIRCUIT BOARD</p>
    <button onclick="startGame()">INITIATE SYSTEM</button>
</div>

<script>
    let rc = 0, gameActive = false, size = 4;
    let tiles = [];
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(f, type="sine", d=0.3) {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(f, audioCtx.currentTime);
        osc.connect(g); g.connect(audioCtx.destination);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + d);
        osc.start(); osc.stop(audioCtx.currentTime + d);
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        gameActive = true;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        buildGrid();
    }

    function buildGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';
        tiles = [];

        for (let i = 0; i < size * size; i++) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            
            // Types: 0 (Straight), 1 (Corner), 2 (T-shape)
            const typeProb = Math.random();
            const type = typeProb > 0.7 ? 2 : (typeProb > 0.35 ? 1 : 0);
            const rot = Math.floor(Math.random() * 4) * 90;
            
            tile.dataset.type = type;
            tile.dataset.rotation = rot;
            tile.dataset.id = i;
            
            let path = "";
            if(type === 0) path = `<path d="M 50 0 L 50 100" />`; // Straight
            else if(type === 1) path = `<path d="M 50 100 L 50 50 L 100 50" />`; // Corner
            else path = `<path d="M 0 50 L 100 50 M 50 50 L 50 100" />`; // T-Shape

            tile.innerHTML = `<svg viewBox="0 0 100 100">${path}</svg>`;
            tile.style.transform = `rotate(${rot}deg)`;
            tile.onclick = () => rotate(tile);
            gridEl.appendChild(tile);
            tiles.push(tile);
        }
        solve();
    }

    function rotate(tile) {
        if(!gameActive) return;
        let rot = parseInt(tile.dataset.rotation) + 90;
        tile.dataset.rotation = rot;
        tile.style.transform = `rotate(${rot}deg)`;
        playSound(300 + (parseInt(tile.dataset.id) * 20), 'triangle', 0.1);
        solve();
    }

    function getExits(tile) {
        let r = (parseInt(tile.dataset.rotation) % 360 + 360) % 360;
        let type = parseInt(tile.dataset.type);
        
        // Directions: 0:Top, 1:Right, 2:Bottom, 3:Left
        if (type === 0) { // Straight
            return (r % 180 === 0) ? [0, 2] : [1, 3];
        } 
        if (type === 1) { // Corner
            if (r === 0) return [2, 1];
            if (r === 90) return [3, 2];
            if (r === 180) return [0, 3];
            return [1, 0];
        }
        if (type === 2) { // T-Shape
            if (r === 0) return [3, 1, 2];
            if (r === 90) return [0, 2, 3];
            if (r === 180) return [1, 3, 0];
            return [2, 0, 1];
        }
    }

    function solve() {
        tiles.forEach(t => t.classList.remove('active'));
        let queue = [];
        let connected = new Set();

        // Input at Top-Left (Tile 0)
        let firstExits = getExits(tiles[0]);
        if (firstExits.includes(0)) { 
            queue.push(0);
            connected.add(0);
        }

        while (queue.length > 0) {
            let currIdx = queue.shift();
            let currTile = tiles[currIdx];
            currTile.classList.add('active');
            let exits = getExits(currTile);

            const neighbors = [
                { dir: 0, next: currIdx - size, opp: 2 }, // Top
                { dir: 1, next: currIdx + 1, opp: 3 },    // Right
                { dir: 2, next: currIdx + size, opp: 0 }, // Bottom
                { dir: 3, next: currIdx - 1, opp: 1 }     // Left
            ];

            neighbors.forEach(n => {
                if (exits.includes(n.dir)) {
                    // Grid boundaries
                    if (n.dir === 1 && (currIdx + 1) % size === 0) return;
                    if (n.dir === 3 && currIdx % size === 0) return;
                    
                    if (n.next >= 0 && n.next < tiles.length) {
                        if (!connected.has(n.next)) {
                            let nextExits = getExits(tiles[n.next]);
                            if (nextExits.includes(n.opp)) {
                                connected.add(n.next);
                                queue.push(n.next);
                            }
                        }
                    }
                }
            });
        }

        let power = Math.floor((connected.size / tiles.length) * 100);
        document.getElementById('p-level').innerText = power;

        // Win Condition: Output at Bottom-Right (Tile 15) connected and has bottom exit
        if (connected.has(tiles.length - 1) && getExits(tiles[tiles.length-1]).includes(2)) {
            victory();
        }
    }

    function victory() {
        gameActive = false;
        playSound(400, 'square', 0.2);
        setTimeout(() => playSound(600, 'square', 0.4), 150);
        rc += 150;
        document.getElementById('rc').innerText = rc;
        
        setTimeout(() => {
            alert("SYSTEM RESTORED! Energy Grid Online.");
            gameActive = true;
            buildGrid();
        }, 600);
    }
</script>
</body>
</html>